{
  "_args": [
    [
      {
        "raw": "thunks@^4.5.1",
        "scope": null,
        "escapedName": "thunks",
        "name": "thunks",
        "rawSpec": "^4.5.1",
        "spec": ">=4.5.1 <5.0.0",
        "type": "range"
      },
      "/Private_Workspace/es6/node_modules/gulp-sequence"
    ]
  ],
  "_from": "thunks@>=4.5.1 <5.0.0",
  "_id": "thunks@4.8.0",
  "_inCache": true,
  "_location": "/thunks",
  "_nodeVersion": "8.0.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/thunks-4.8.0.tgz_1496197065322_0.366606121417135"
  },
  "_npmUser": {
    "name": "zensh",
    "email": "admin@zensh.com"
  },
  "_npmVersion": "5.0.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "thunks@^4.5.1",
    "scope": null,
    "escapedName": "thunks",
    "name": "thunks",
    "rawSpec": "^4.5.1",
    "spec": ">=4.5.1 <5.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/gulp-sequence"
  ],
  "_resolved": "https://registry.npmjs.org/thunks/-/thunks-4.8.0.tgz",
  "_shasum": "63d5fff7f6a957d6953c46dc72829dd5462a8ab4",
  "_shrinkwrap": null,
  "_spec": "thunks@^4.5.1",
  "_where": "/Private_Workspace/es6/node_modules/gulp-sequence",
  "authors": [
    "Yan Qing <admin@zensh.com>"
  ],
  "bugs": {
    "url": "https://github.com/thunks/thunks/issues"
  },
  "dependencies": {},
  "description": "A small and magical composer for all JavaScript asynchronous.",
  "devDependencies": {
    "@types/node": "^7.0.14",
    "async": "^2.4.1",
    "bluebird": "^3.5.0",
    "co": "^4.6.0",
    "istanbul": "^0.4.5",
    "jsbench": "^1.1.0",
    "promise": "^7.1.1",
    "regenerator": "^0.9.7",
    "should": "^11.2.1",
    "standard": "^10.0.2",
    "thenjs": "^2.0.5",
    "tman": "^1.6.7",
    "ts-node": "^3.0.4",
    "typescript": "^2.3.3"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-teNRPuAioKpeHMmuG6czaKxJ3zd7Ny3r7ke8S9wSrlrSOgLxO3sJ3zbNu4iTlZAr/xylrFetNASw7pBW+EomPg==",
    "shasum": "63d5fff7f6a957d6953c46dc72829dd5462a8ab4",
    "tarball": "https://registry.npmjs.org/thunks/-/thunks-4.8.0.tgz"
  },
  "files": [
    "README.md",
    "index.d.ts",
    "thunks.js",
    "thunks.es6.js"
  ],
  "gitHead": "fd4fd54560bb1dad0d63c1906af08618634d9871",
  "homepage": "https://github.com/thunks/thunks",
  "jsnext:main": "thunks.es6.js",
  "keywords": [
    "async",
    "thunk",
    "thunks",
    "promise",
    "future",
    "flow",
    "yield",
    "generator",
    "coro",
    "compose",
    "coroutine",
    "orchestrate"
  ],
  "license": "MIT",
  "main": "thunks.js",
  "maintainers": [
    {
      "name": "zensh",
      "email": "admin@zensh.com"
    }
  ],
  "name": "thunks",
  "optionalDependencies": {},
  "readme": "thunks\n====\nA small and magical composer for all JavaScript asynchronous.\n\n[![NPM version][npm-image]][npm-url]\n[![Build Status][travis-image]][travis-url]\n[![js-standard-style][js-standard-image]][js-standard-url]\n[![Coverage Status][coveralls-image]][coveralls-url]\n[![Downloads][downloads-image]][downloads-url]\n\n[中文说明](https://github.com/thunks/thunks/blob/master/docs/api-zh.md)\n\n[thunks 的作用域和异常处理设计](https://github.com/thunks/thunks/blob/master/docs/scope-and-error-catch.md)\n\n## Compatibility\n\nES5+, support node.js and browsers.\n\n## Summary\n- [Implementations](#implementations)\n- [What is a thunk?](#what-is-a-thunk)\n- [Demo](#demo)\n- [Installation](#installation)\n- [API](#api)\n  - [thunks([scope])](#thunksscope)\n  - [thunks.pruneErrorStack](#thunkspruneerrorstack)\n  - [thunks.onerror\\(error\\)](#thunksonerrorerror)\n  - [Class thunks.Scope](#class-thunksscope)\n  - [thunk(thunkable)](#thunkthunkable)\n  - [thunk.all(obj)](#thunkallobj)\n  - [thunk.all(thunkable1, ..., thunkableN)](thunkallthunkable1--thunkablen)\n  - [thunk.seq([thunkable1, ..., thunkableN])](#thunkseqthunkable1--thunkablen)\n  - [thunk.seq(thunkable1, ..., thunkableN)](#thunkseqthunkable1--thunkablen-1)\n  - [thunk.race([thunkable1, ..., thunkableN])](#thunkracethunkable1--thunkablen)\n  - [thunk.race(thunkable1, ..., thunkableN)](#thunkracethunkable1--thunkablen-1)\n  - [thunk.thunkify(fn)](#thunkthunkifyfn)\n  - [thunk.lift(fn)](#thunkliftfn)\n  - [thunk.persist(thunkable)](#thunkpersistthunkable)\n  - [thunk.delay(delay)](#thunkdelaydelay)\n  - [thunk.stop([messagge])](#thunkstopmessagge)\n  - [thunk.cancel()](#thunkcancel)\n- [TypeScript Typings](#typescript-typings)\n- [What functions are thunkable?](#what-functions-are-thunkable)\n- [License MIT](#license)\n\n## Implementations:\n\n- [Toa](https://github.com/toajs/toa) A powerful web framework rely on thunks.\n- [T-man](https://github.com/thunks/tman) Super test manager for JavaScript.\n- [thunk-redis](https://github.com/thunks/thunk-redis) The fastest thunk/promise-based redis client, support all redis features.\n- [thunk-disque](https://github.com/thunks/thunk-disque) A thunk/promise-based disque client.\n- [thunk-stream](https://github.com/thunks/thunk-stream) Wrap a readable/writable/duplex/transform stream to a thunk.\n- [thunk-queue](https://github.com/thunks/thunk-queue) A thunk queue for uncertainty tasks evaluation.\n- [thunk-loop](https://github.com/thunks/thunk-loop) Asynchronous tasks loop (while (true) { ... }).\n- [thunk-mocha](https://github.com/thunks/thunk-mocha) Enable support for generators in Mocha with backward compatibility.\n- [thunk-ratelimiter](https://github.com/thunks/thunk-ratelimiter) The fastest abstract rate limiter.\n- [thunk-workers](https://github.com/thunks/thunk-workers) Thunk-based task scheduler that executes synchrounous and/or asynchronous tasks under concurrency control.\n- [file-cache](https://github.com/thunks/file-cache) Read file with caching, rely on thunks.\n\nAnd a mountain of applications in server-side or client-side.\n\n## What is a thunk?\n\n0. [ALGOL thunks in 1961](http://archive.computerhistory.org/resources/text/algol/ACM_Algol_bulletin/1064045/frontmatter.pdf)\n\n1. **`thunk`** is a function that encapsulates synchronous or asynchronous code inside.\n\n2. **`thunk`** accepts only one `callback` function as an arguments, which is a CPS function.\n\n3. **`thunk`** returns another **`thunk`** function after being called, for chaining operations.\n\n4. **`thunk`** passes the results into a `callback` function after being excuted.\n\n5. If the return value of `callback` is a **`thunk`** function, then it will be executed first and its result will be sent to another **`thunk`** for excution,\nor it will be sent to another new **`thunk`** function as the value of the computation.\n\n## Demo\n\n```js\nconst thunk = require('thunks')()\nconst fs = require('fs')\nconst size = thunk.thunkify(fs.stat)\n\n// generator\nthunk(function * () {\n\n  // sequential\n  console.log(yield size('.gitignore'))\n  console.log(yield size('thunks.js'))\n  console.log(yield size('package.json'))\n})(function * (error, res) {\n  //parallel\n  console.log(yield thunk.all([\n    size('.gitignore'),\n    size('thunks.js'),\n    size('package.json')\n  ]))\n})()\n```\n\n```js\nconst thunk = require('thunks')()\nconst fs = require('fs')\nconst size = thunk.thunkify(fs.stat)\n\n// sequential\nsize('.gitignore')(function (error, res) {\n  console.log(error, res)\n  return size('thunks.js')\n\n})(function (error, res) {\n  console.log(error, res)\n  return size('package.json')\n\n})(function (error, res) {\n  console.log(error, res)\n})\n\n// parallel\nthunk.all([\n  size('.gitignore'),\n  size('thunks.js'),\n  size('package.json')\n])(function (error, res) {\n  console.log(error, res)\n})\n\n// sequential\nthunk.seq([\n  size('.gitignore'),\n  size('thunks.js'),\n  size('package.json')\n])(function (error, res) {\n  console.log(error, res)\n})\n```\n\n### There is a breaking change in V4.x relative to V3.x, two or more results will become an array of results.\n\n**v3.x:**\n```js\nthunk(function (done) {\n  done(null, 1, 2, 3)\n})(function (error, res) {\n  console.log.apply(console, arguments)\n  // output: `null, 1, 2, 3`\n})\n```\n\n**v4.x:**\n```js\nthunk(function (done) {\n  done(null, 1, 2, 3)\n})(function (error, res) {\n  console.log.apply(console, arguments)\n  // output: `null, [1, 2, 3]`\n})\n```\n\nif there is an `error`, the arguments will be explicitly `error`, otherwise the `error` will always be `null`(In all versions).\n\n## Installation\n\n**Node.js:**\n\n    npm install thunks\n\n**Bower:**\n\n    bower install thunks\n\n**browser:**\n\n```html\n<script src=\"/pathTo/thunks.js\"></script>\n```\n\n## API\n\n```js\nconst thunks = require('thunks')\n```\n\n### thunks([scope])\n\nMatrix of `thunk`, it generates a `thunkFunction` factory (named `thunk`) with it's scope.\n\"scope\" refers to the running evironments `thunk` generated(directly or indirectly) for all child thunk functions.\n\n1. Here's how you create a basic `thunk`, any exceptions would be passed the next child thunk function:\n\n  ```js\n  const thunk = thunks()\n  ```\n\n2. Here's the way to create a `thunk` listening to all exceptions in current scope with `onerror`,\nand it will make sure the exceptions are not being passed to the followed child thunk function, unless `onerror` function returns `true`.\n\n  ```js\n  const thunk = thunks(function (error) { console.error(error) })\n  ```\n\n  **Equals:**\n  ```js\n  const scope = new thunks.Scope(function (error) { console.error(error) })\n  const thunk = thunks(scope)\n  ```\n\n3. Create a `thunk` with `onerror`, `onstop` and `debug` listeners.\nResults of this `thunk` would be passed to `debug` function first before passing to the followed child thunk function.\n\n  ```js\n  const thunk = thunks({\n    onstop: function (sig) { console.log(sig) },\n    onerror: function (error) { console.error(error) },\n    debug: function () { console.log.apply(console, arguments) }\n  })\n  ```\n\n  **Equals:**\n  ```js\n  const scope = new thunks.Scope({\n    onstop: function (sig) { console.log(sig) },\n    onerror: function (error) { console.error(error) },\n    debug: function () { console.log.apply(console, arguments) }\n  })\n  const thunk = thunks(scope)\n  ```\nThe context of `onerror`, `onstop` and `debug` is a `scope`.\nEven multiple `thunk` main functions with different scopes are composed,\neach scope would be separate from each other,\nwhich means, `onerror`, `onstop` and `debug` would not run in other scopes.\n\n### thunks.pruneErrorStack\nDefault to `true`, means it will prune error stack message.\n\n### thunks.onerror(error)\nDefault to `null`, it is a global error handler.\n\n### Class thunks.Scope\n\n```js\nconst scope = new thunks.Scope({\n  onstop: function (sig) { assert.strictEqual(this, scope) },\n  onerror: function (error) { assert.strictEqual(this, scope) },\n  debug: function () { assert.strictEqual(this, scope) }\n})\nconst thunk = thunks(scope)\n```\n\n### thunk(thunkable)\n\nThis is the `thunkFunction` factory, to create new `thunkFunction` functions.\n\nThe parameter `thunkable` value could be:\n\n1. a `thunkFunction` function, by calling this function a new `thunkFunction` function will be returned\n\n  ```js\n  let thunk1 = thunk(1)\n  thunk(thunk1)(function (error, value) {\n    console.log(error, value) // null 1\n  })\n  ```\n\n2. a thunkLike function `function (callback) {}`, when called, passes its results to the next `thunkFunction` function\n\n  ```js\n  thunk(function (callback) {\n    callback(null, 1)\n  })(function (error, value) {\n    console.log(error, value) // null 1\n  })\n  ```\n\n3. a Promise object, results of Promise would be passed to a new `thunkFunction` function\n\n  ```js\n  let promise = Promise.resolve(1)\n\n  thunk(promise)(function (error, value) {\n    console.log(error, value) // null 1\n  })\n  ```\n\n4. objects which implements the method `toThunk`\n\n  ```js\n  let obj = {\n    toThunk: function () {\n      return function (done) { done(null, 1) }\n    }\n  }\n  // `obj` has `toThunk` method that returns a thunk function\n  thunk(obj)(function (error, value) {\n    console.log(error, value) // null 1\n  })\n  ```\n\n5. objects which implement the method `toPromise`\n\n  ```js\n  const Rx = require('rxjs')\n  // Observable instance has `toPromise` method that returns a promise\n  thunk(Rx.Observable.fromPromise(Promise.resolve(123)))(function (error, value) {\n    console.log(error, value) // null 123\n  })\n  ```\n\n6. Generator and Generator Function, like `co`, but `yield` anything\n\n  ```js\n  thunk(function * () {\n    var x = yield 10\n    return 2 * x\n  })(function * (error, res) {\n    console.log(error, res) // null, 20\n\n    return yield thunk.all([1, 2, thunk(3)])\n  })(function * (error, res) {\n    console.log(error, res) // null, [1, 2, 3]\n    return yield thunk.all({\n      name: 'test',\n      value: thunk(1)\n    })\n  })(function (error, res) {\n    console.log(error, res) // null, {name: 'test', value: 1}\n  })\n  ```\n\n7. async/await function\n\n  ```js\n  thunk(async function () {\n    console.log(await Promise.resolve('await promise in an async function'))\n\n    try {\n      await new Promise((resolve, reject) => {\n        setTimeout(() => reject('catch promise error in async function'), 1000)\n      })\n    } catch (err) {\n      console.log(err)\n    }\n  })(function * () {\n    console.log(yield async () => 'yield an async function in generator function')\n  })()\n  ```\n\n8. values in other types that would be valid results to pass to a new child thunk function\n\n  ```js\n  thunk(1)(function (error, value) {\n    console.log(error, value) // null 1\n  })\n\n  thunk([1, 2, 3])(function (error, value) {\n    console.log(error, value) // null [1, 2, 3]\n  })\n  ```\n\nYou can also run with `this`:\n\n  ```js\n  thunk.call({x: 123}, 456)(function (error, value) {\n    console.log(error, this.x, value) // null 123 456\n    return 'thunk!'\n  })(function (error, value) {\n    console.log(error, this.x, value) // null 123 'thunk!'\n  })\n  ```\n\n### thunk.all(obj)\n### thunk.all(thunkable1, ..., thunkableN)\n\nReturns a child thunk function.\n\n`obj` can be an array or an object that contains any value. `thunk.all` will transform value to a child thunk function and excute it in parallel. After all of them are finished, an array containing results(in its original order) would be passed to the a new child thunk function.\n\n```js\nthunk.all([\n  thunk(0),\n  function * () { return yield 1 },\n  2,\n  thunk(function (callback) { callback(null, [3]) })\n])(function (error, value) {\n  console.log(error, value) // null [0, 1, 2, [3]]\n})\n\nthunk.all({\n  a: thunk(0),\n  b: thunk(1),\n  c: 2,\n  d: thunk(function (callback) { callback(null, [3]) })\n})(function (error, value) {\n  console.log(error, value) // null {a: 0, b: 1, c: 2, d: [3]}\n})\n```\n\nYou may also write code like this:\n\n```js\nthunk.all.call({x: [1, 2, 3]}, [4, 5, 6])(function (error, value) {\n  console.log(error, this.x, value) // null [1, 2, 3] [4, 5, 6]\n  return 'thunk!'\n})(function (error, value) {\n  console.log(error, this.x, value) // null [1, 2, 3] 'thunk!'\n})\n```\n\n### thunk.seq([thunkable1, ..., thunkableN])\n### thunk.seq(thunkable1, ..., thunkableN)\n\nReturns a child thunk function.\n\n`thunkX` can be any value, `thunk.seq` will transform value to a child thunk function and excute it in order. After all of them are finished, an array containing results(in its original order) would be passed to the a new child thunk function.\n\n```js\nthunk.seq([\n  function (callback) {\n    setTimeout(function () {\n      callback(null, 'a', 'b')\n    }, 100)\n  },\n  thunk(function (callback) {\n    callback(null, 'c')\n  }),\n  [thunk('d'), function * () { return yield 'e' }], // thunk in array will be excuted in parallel\n  function (callback) {\n    should(flag).be.eql([true, true])\n    flag[2] = true\n    callback(null, 'f')\n  }\n])(function (error, value) {\n  console.log(error, value) // null [['a', 'b'], 'c', ['d', 'e'], 'f']\n})\n```\nor\n\n```js\nthunk.seq(\n  function (callback) {\n    setTimeout(function () {\n      callback(null, 'a', 'b')\n    }, 100)\n  },\n  thunk(function (callback) {\n    callback(null, 'c')\n  }),\n  [thunk('d'), thunk('e')], // thunk in array will be excuted in parallel\n  function (callback) {\n    should(flag).be.eql([true, true])\n    flag[2] = true\n    callback(null, 'f')\n  }\n)(function (error, value) {\n  console.log(error, value) // null [['a', 'b'], 'c', ['d', 'e'], 'f']\n})\n```\n\nYou may also write code like this:\n\n```js\nthunk.seq.call({x: [1, 2, 3]}, 4, 5, 6)(function (error, value) {\n  console.log(error, this.x, value) // null [1, 2, 3] [4, 5, 6]\n  return 'thunk!'\n})(function (error, value) {\n  console.log(error, this.x, value) // null [1, 2, 3] 'thunk!'\n})\n```\n\n### thunk.race([thunkable1, ..., thunkableN])\n### thunk.race(thunkable1, ..., thunkableN)\n\nReturns a child thunk function with the value or error from one first completed.\n\n### thunk.thunkify(fn)\n\nReturns a new function that would return a child thunk function\n\nTransform a `fn` function which is in Node.js style into a new function.\nThis new function does not accept a `callback` as an argument, but accepts child thunk functions.\n\n```js\nconst thunk = require('thunks')()\nconst fs = require('fs')\nconst fsStat = thunk.thunkify(fs.stat)\n\nfsStat('thunks.js')(function (error, result) {\n  console.log('thunks.js: ', result)\n})\nfsStat('.gitignore')(function (error, result) {\n  console.log('.gitignore: ', result)\n})\n```\n\nYou may also write code with `this`:\n\n```js\nlet obj = {a: 8}\nfunction run (x, callback) {\n  //...\n  callback(null, this.a * x)\n}\n\nlet run = thunk.thunkify.call(obj, run)\n\nrun(1)(function (error, result) {\n  console.log('run 1: ', result)\n})\nrun(2)(function (error, result) {\n  console.log('run 2: ', result)\n})\n```\n\n### thunk.lift(fn)\n\n`lift` comes from Haskell, it transforms a synchronous function `fn` into a new async function.\nThis new function will accept `thunkable` arguments, evaluate them, then run as the original function `fn`. The new function returns a child thunk function.\n\n```js\nconst thunk = require('thunks')()\n\nfunction calculator (a, b, c) {\n  return (a + b + c) * 10\n}\n\nconst calculatorT = thunk.lift(calculator)\n\nlet value1 = thunk(2)\nlet value2 = Promise.resolve(3)\n\ncalculatorT(value1, value2, 5)(function (error, result) {\n  console.log(result) // 100\n})\n```\n\nYou may also write code with `this`:\n\n```js\nconst calculatorT = thunk.lift.call(context, calculator)\n```\n\n### thunk.persist(thunkable)\n\nit transforms `thunkable` value to a persist thunk function, which can be called more than once with the same result(like a promise). The new function returns a child thunk function.\n\n```js\nconst thunk = require('thunks')()\n\nlet persistThunk = thunk.persist(thunk(x))\n\npersistThunk(function (error, result) {\n  console.log(1, result) // x\n  return persistThunk(function (error, result) {\n    console.log(2, result) // x\n    return persistThunk\n  })\n})(function (error, result) {\n  console.log(3, result) // x\n})\n```\n\nYou may also write code with `this`:\n\n```js\nconst persistThunk = thunk.persist.call(context, thunkable)\n```\n\n### thunk.delay(delay)\n\nReturn a child thunk function, this child thunk function will be called after `delay` milliseconds.\n\n```js\nconsole.log('thunk.delay 500: ', Date.now())\nthunk.delay(500)(function () {\n  console.log('thunk.delay 1000: ', Date.now())\n  return thunk.delay(1000)\n})(function () {\n  console.log('thunk.delay end: ', Date.now())\n})\n```\n\nYou may also write code with `this`:\n\n```js\nconsole.log('thunk.delay start: ', Date.now())\nthunk.delay.call(this, 1000)(function () {\n  console.log('thunk.delay end: ', Date.now())\n})\n```\n\n### thunk.stop([message])\n\nThis will stop control flow process with a message similar to Promise's cancelable(not implemented yet). It will throw a stop signal object.\nStop signal is an object with a message and `status === 19`(POSIX signal SIGSTOP) and a special code. Stop signal can be caught by `onstop`, and aslo can be caught by `try catch`, in this case it will not trigger `onstop`.\n\n```js\nconst thunk = require('thunks')({\n  onstop: function (res) {\n    if (res) console.log(res.code, res.status, res) // SIGSTOP 19 { message: 'Stop now!' }\n  }\n})\n\nthunk(function (callback) {\n  thunk.stop('Stop now!')\n  console.log('It will not run!')\n})(function (error, value) {\n  console.log('It will not run!', error)\n})\n```\n\n```js\nthunk.delay(100)(function () {\n  console.log('Hello')\n  return thunk.delay(100)(function () {\n    thunk.stop('Stop now!')\n    console.log('It will not run!')\n  })\n})(function (error, value) {\n  console.log('It will not run!')\n})\n```\n\n### thunk.cancel()\n\nThis will cancel all control flow process in the current thunk's scope.\n\n## TypeScript Typings\n\n```typescript\nimport * as assert from 'assert'\nimport { thunk, thunks, isGeneratorFn } from 'thunks'\n// or: import * as thunks from 'thunks'\n\nthunk(function * () {\n  assert.strictEqual(yield thunks()(1), 1)\n  assert.ok(isGeneratorFn(function * () {}))\n\n  while (true) {\n    yield function (done) { setTimeout(done, 1000) }\n    console.log('Dang!')\n  }\n})()\n```\n\n## What functions are thunkable?\n\nthunks supports so many [thunkable](#thunkthunkable) objects. There are three kind of functions:\n\n- thunk-like function `function (callback) { callback(err, someValue) }`\n- generator function `function * () { yield something }`\n- async/await function `async function () { await somePromise }`\n\nthunks can't support common functions (non-thunk-like functions). thunks uses `fn.length === 1` to recognize thunk-like functions.\n\nUsing a common function in this way will throw an error:\n```js\nthunk(function () {})(function (err) {\n  console.log(1, err) // 1 [Error: Not thunkable function: function () {}]\n})\n\nthunk(function (a, b) {})(function (err) {\n  console.log(2, err) // 2 [Error: Not thunkable function: function (a, b) {}]\n})\n\nthunk(function () { let callback = arguments[0]; callback() })(function (err) {\n  console.log(3, err) // 3 [Error: Not thunkable function: function () { let callback = arguments[0]; callback() }]\n})\n\nthunk()(function () {\n  return function () {} // can't return a non-thunkable function.\n})(function (err) {\n  console.log(4, err) // 4 [Error: Not thunkable function: function () {}]\n})\n```\nSo pay attention to that. **We can't return a non-thunkable function** in thunk. If we return a thunkable function, thunk will evaluate it as an asynchronous task.\n\n## License\nthunks is licensed under the [MIT](https://github.com/thunks/tman/blob/master/LICENSE) license.\nCopyright &copy; 2015-2017 thunks.\n\n[npm-url]: https://npmjs.org/package/thunks\n[npm-image]: http://img.shields.io/npm/v/thunks.svg\n\n[travis-url]: https://travis-ci.org/thunks/thunks\n[travis-image]: http://img.shields.io/travis/thunks/thunks.svg\n\n[coveralls-url]: https://coveralls.io/r/thunks/thunks\n[coveralls-image]: https://coveralls.io/repos/thunks/thunks/badge.svg\n\n[downloads-url]: https://npmjs.org/package/thunks\n[downloads-image]: http://img.shields.io/npm/dm/thunks.svg?style=flat-square\n\n[js-standard-url]: https://github.com/feross/standard\n[js-standard-image]: https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/thunks/thunks.git"
  },
  "scripts": {
    "bench": "node benchmark/index",
    "test": "standard && tman test/index",
    "test-cov": "istanbul cover _tman test/index",
    "test-typings": "tman -r ts-node/register test/typings.test.ts"
  },
  "typings": "index.d.ts",
  "version": "4.8.0"
}
